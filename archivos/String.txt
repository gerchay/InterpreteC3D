call MAIN();
void MAIN(){
	Stack[0] = 0; //Valor de retorno
	Stack[1] = 0; //Entorno actual

	T0 = h;
	Heap[h] = 104; //h
	h = h + 1;
	Heap[h] = 111; //o
	h = h + 1;
	Heap[h] = 108; //l
	h = h + 1;
	Heap[h] = 97; //a
	h = h + 1;
	Heap[h] = 32;
	h = h + 1;
	Heap[h] = 109; //m
	h = h + 1;
	Heap[h] = 117; //u
	h = h + 1;
	Heap[h] = 110; //n
	h = h + 1;
	Heap[h] = 100; //d
	h = h + 1;
	Heap[h] = 111; //o
	h = h + 1;
	Heap[h] = 36; //$
	h = h + 1;

	Stack[2] = T0; //Guardando la variable x en la posicion 2 del Stack, se guarda la referencia al heap

	T0 = Stack[2]; //Apuntador al heap de la variable x
	T1 = p + 3; //Cambio de Entorno virtual
	Stack[T1] = T0; //Pasando primer variable
	p = p + 3; //Cambio de Entorno real
	call Native_PrintString();
	p = p - 3; //Regreso al Entorno anterior
	print(%c,10); //Salto de linea
	L0:
}
void Native_Concat_String_String(){
	T2 = h;
	T3 = p + 1;
	T4 = Stack[T3];
	T5 = Heap[T4];
	L1:
	if (T5 == 36) goto L2;
	Heap[h] = T5;
	h = h + 1;
	T4 = T4 + 1;
	T5 = Heap[T4];
	goto L1;
	L2:
	T3 = p + 2;
	T4 = Stack[T3];
	T5 = Heap[T4];
	L3:
	if (T5 == 36) goto L4;
	Heap[h] = T5;
	h = h + 1;
	T4 = T4 + 1;
	T5 = Heap[T4];
	goto L3;
	L4:
	Heap[h] = 36;
	h = h + 1;
	Stack[p] = T2;
}
void Native_PrintString(){
	T2 = p + 0;
	T3 = Stack[T2];
	if (T3 != -1) goto L17;
	print(%c,78); //N
	print(%c,73); //I
	print(%c,76); //L
	goto L19;
	L17:
	T4 = Heap[T3];
	L18:
	if (T4 == 36) goto L19;
	print(%c,T4);
	T3 = T3 + 1;
	T4 = Heap[T3];
	goto L18;
	L19:
}
void Native_Malloc(){
	T1 = p + 2;
	T2 = Stack[T1];
	T1 = h;
	L62:
	if (T2 <= 0) goto L63;
	h = h + 1;
	T2 = T2 - 1;
	goto L62;
	L63:
	Stack[p] = T1;
}
